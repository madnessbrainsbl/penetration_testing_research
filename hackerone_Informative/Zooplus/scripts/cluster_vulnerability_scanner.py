#!/usr/bin/env python3
"""
Cluster Vulnerability Scanner для Zooplus
Ищет уязвимости в кластерной инфраструктуре (Istio, Kubernetes, Envoy)
"""

import requests
import json
import sys
from urllib.parse import urljoin
from datetime import datetime
import ssl
import socket

class ClusterScanner:
    def __init__(self, target="www.zooplus.de"):
        self.target = target
        self.base_url = f"https://{target}"
        self.findings = []
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        })
    
    def log_finding(self, severity, title, description, endpoint=None, evidence=None):
        """Логирует найденную уязвимость"""
        finding = {
            "severity": severity,
            "title": title,
            "description": description,
            "endpoint": endpoint,
            "evidence": evidence,
            "timestamp": datetime.now().isoformat()
        }
        self.findings.append(finding)
        print(f"[{severity}] {title}")
        if endpoint:
            print(f"    Endpoint: {endpoint}")
        if evidence:
            print(f"    Evidence: {evidence}")
    
    def check_istio_envoy_exposure(self):
        """Проверяет доступность Istio/Envoy endpoints"""
        print("\n[*] Checking Istio/Envoy exposure...")
        
        # Envoy admin endpoints
        envoy_endpoints = [
            "/stats",
            "/stats/prometheus",
            "/server_info",
            "/clusters",
            "/listeners",
            "/config_dump",
            "/runtime",
            "/hot_restart_version",
            "/logging",
            "/memory",
            "/reset_counters",
            "/certs",
            "/ready",
            "/healthcheck/ready",
            "/healthcheck/fail"
        ]
        
        for endpoint in envoy_endpoints:
            try:
                url = urljoin(self.base_url, endpoint)
                resp = self.session.get(url, timeout=5, verify=False)
                
                if resp.status_code == 200:
                    self.log_finding(
                        "CRITICAL",
                        f"Istio/Envoy Admin Endpoint Exposed: {endpoint}",
                        f"Envoy admin endpoint {endpoint} is publicly accessible. This can expose cluster configuration, metrics, and allow DoS attacks.",
                        endpoint=url,
                        evidence=f"Status: {resp.status_code}, Response length: {len(resp.text)}"
                    )
                elif resp.status_code in [401, 403]:
                    print(f"    [+] {endpoint} - Protected (good)")
            except Exception as e:
                pass
    
    def check_kubernetes_api_exposure(self):
        """Проверяет доступность Kubernetes API"""
        print("\n[*] Checking Kubernetes API exposure...")
        
        k8s_endpoints = [
            "/api",
            "/api/v1",
            "/apis",
            "/apis/apps/v1",
            "/healthz",
            "/readyz",
            "/livez",
            "/version",
            "/metrics",
            "/openapi/v2"
        ]
        
        for endpoint in k8s_endpoints:
            try:
                url = urljoin(self.base_url, endpoint)
                resp = self.session.get(url, timeout=5, verify=False)
                
                if resp.status_code == 200:
                    # Check if it looks like K8s API
                    if "kind" in resp.text.lower() or "apiVersion" in resp.text:
                        self.log_finding(
                            "CRITICAL",
                            f"Kubernetes API Exposed: {endpoint}",
                            f"Kubernetes API endpoint is publicly accessible. This is extremely dangerous.",
                            endpoint=url,
                            evidence=f"Status: {resp.status_code}"
                        )
            except Exception as e:
                pass
    
    def check_istio_telemetry(self):
        """Проверяет Istio telemetry endpoints"""
        print("\n[*] Checking Istio telemetry endpoints...")
        
        telemetry_endpoints = [
            "/metrics",
            "/prometheus",
            "/stats",
            "/debug",
            "/debug/pprof",
            "/debug/pprof/goroutine",
            "/debug/pprof/heap",
            "/debug/pprof/profile"
        ]
        
        for endpoint in telemetry_endpoints:
            try:
                url = urljoin(self.base_url, endpoint)
                resp = self.session.get(url, timeout=5, verify=False)
                
                if resp.status_code == 200:
                    # Check if it contains sensitive metrics
                    if "istio" in resp.text.lower() or "envoy" in resp.text.lower():
                        self.log_finding(
                            "HIGH",
                            f"Istio Telemetry Exposed: {endpoint}",
                            f"Telemetry endpoint exposes cluster metrics and internal information.",
                            endpoint=url,
                            evidence=f"Contains Istio/Envoy metrics"
                        )
            except Exception as e:
                pass
    
    def check_service_mesh_config(self):
        """Проверяет конфигурацию service mesh"""
        print("\n[*] Checking service mesh configuration...")
        
        # Check for Istio configuration leaks
        config_endpoints = [
            "/.well-known/istio",
            "/.well-known/istio-config",
            "/istio/config",
            "/mesh/config"
        ]
        
        for endpoint in config_endpoints:
            try:
                url = urljoin(self.base_url, endpoint)
                resp = self.session.get(url, timeout=5, verify=False)
                
                if resp.status_code == 200:
                    self.log_finding(
                        "HIGH",
                        f"Service Mesh Config Exposed: {endpoint}",
                        f"Service mesh configuration is publicly accessible.",
                        endpoint=url
                    )
            except Exception as e:
                pass
    
    def check_health_endpoints(self):
        """Проверяет health check endpoints на утечки информации"""
        print("\n[*] Checking health endpoints...")
        
        health_endpoints = [
            "/health",
            "/healthz",
            "/ready",
            "/readyz",
            "/live",
            "/livez",
            "/status",
            "/ping"
        ]
        
        for endpoint in health_endpoints:
            try:
                url = urljoin(self.base_url, endpoint)
                resp = self.session.get(url, timeout=5, verify=False)
                
                if resp.status_code == 200:
                    # Check for information disclosure
                    response_lower = resp.text.lower()
                    sensitive_info = ["version", "build", "commit", "hostname", "pod", "namespace", "cluster"]
                    
                    found_info = [info for info in sensitive_info if info in response_lower]
                    if found_info:
                        self.log_finding(
                            "MEDIUM",
                            f"Information Disclosure in Health Endpoint: {endpoint}",
                            f"Health endpoint exposes sensitive information: {', '.join(found_info)}",
                            endpoint=url,
                            evidence=resp.text[:200]
                        )
            except Exception as e:
                pass
    
    def check_metadata_endpoints(self):
        """Проверяет metadata endpoints (AWS, GCP, Azure)"""
        print("\n[*] Checking cloud metadata endpoints...")
        
        # Check for SSRF to metadata services
        metadata_indicators = [
            "/metadata",
            "/latest/meta-data",
            "/computeMetadata",
            "/metadata/instance"
        ]
        
        for endpoint in metadata_indicators:
            try:
                url = urljoin(self.base_url, endpoint)
                resp = self.session.get(url, timeout=5, verify=False)
                
                if resp.status_code in [200, 403]:
                    self.log_finding(
                        "HIGH",
                        f"Metadata Endpoint Accessible: {endpoint}",
                        f"Cloud metadata endpoint may be accessible (potential SSRF vector).",
                        endpoint=url
                    )
            except Exception as e:
                pass
    
    def check_debug_endpoints(self):
        """Проверяет debug endpoints"""
        print("\n[*] Checking debug endpoints...")
        
        debug_endpoints = [
            "/debug",
            "/debug/pprof",
            "/debug/vars",
            "/debug/requests",
            "/debug/events",
            "/trace",
            "/tracing"
        ]
        
        for endpoint in debug_endpoints:
            try:
                url = urljoin(self.base_url, endpoint)
                resp = self.session.get(url, timeout=5, verify=False)
                
                if resp.status_code == 200:
                    self.log_finding(
                        "MEDIUM",
                        f"Debug Endpoint Exposed: {endpoint}",
                        f"Debug endpoint is publicly accessible and may leak sensitive information.",
                        endpoint=url
                    )
            except Exception as e:
                pass
    
    def check_admin_interfaces(self):
        """Проверяет административные интерфейсы"""
        print("\n[*] Checking admin interfaces...")
        
        admin_endpoints = [
            "/admin",
            "/administrator",
            "/manager",
            "/console",
            "/dashboard",
            "/kibana",
            "/grafana",
            "/prometheus",
            "/jaeger",
            "/kiali"
        ]
        
        for endpoint in admin_endpoints:
            try:
                url = urljoin(self.base_url, endpoint)
                resp = self.session.get(url, timeout=5, verify=False)
                
                if resp.status_code == 200:
                    # Check if it's an admin interface
                    if any(keyword in resp.text.lower() for keyword in ["admin", "dashboard", "login", "grafana", "kibana"]):
                        self.log_finding(
                            "HIGH",
                            f"Admin Interface Exposed: {endpoint}",
                            f"Administrative interface is publicly accessible.",
                            endpoint=url
                        )
            except Exception as e:
                pass
    
    def check_ssl_tls_config(self):
        """Проверяет SSL/TLS конфигурацию"""
        print("\n[*] Checking SSL/TLS configuration...")
        
        try:
            context = ssl.create_default_context()
            with socket.create_connection((self.target, 443), timeout=5) as sock:
                with context.wrap_socket(sock, server_hostname=self.target) as ssock:
                    cert = ssock.getpeercert()
                    cipher = ssock.cipher()
                    
                    # Check for weak ciphers
                    if cipher:
                        cipher_name = cipher[0]
                        if any(weak in cipher_name.lower() for weak in ["rc4", "md5", "sha1", "des", "3des"]):
                            self.log_finding(
                                "MEDIUM",
                                "Weak SSL/TLS Cipher",
                                f"Server uses weak cipher: {cipher_name}",
                                evidence=cipher_name
                            )
        except Exception as e:
            pass
    
    def generate_report(self):
        """Генерирует отчет"""
        report = {
            "target": self.target,
            "scan_date": datetime.now().isoformat(),
            "total_findings": len(self.findings),
            "findings_by_severity": {
                "CRITICAL": len([f for f in self.findings if f["severity"] == "CRITICAL"]),
                "HIGH": len([f for f in self.findings if f["severity"] == "HIGH"]),
                "MEDIUM": len([f for f in self.findings if f["severity"] == "MEDIUM"]),
                "LOW": len([f for f in self.findings if f["severity"] == "LOW"])
            },
            "findings": self.findings
        }
        
        return report

def main():
    import warnings
    warnings.filterwarnings('ignore', message='Unverified HTTPS request')
    
    scanner = ClusterScanner()
    
    print("=" * 70)
    print("ZOOPLUS CLUSTER VULNERABILITY SCANNER")
    print("=" * 70)
    print(f"Target: {scanner.target}")
    print(f"Start Time: {datetime.now()}")
    print("=" * 70)
    
    # Run all checks
    scanner.check_istio_envoy_exposure()
    scanner.check_kubernetes_api_exposure()
    scanner.check_istio_telemetry()
    scanner.check_service_mesh_config()
    scanner.check_health_endpoints()
    scanner.check_metadata_endpoints()
    scanner.check_debug_endpoints()
    scanner.check_admin_interfaces()
    scanner.check_ssl_tls_config()
    
    # Generate report
    report = scanner.generate_report()
    
    # Save report
    import os
    os.makedirs("reports", exist_ok=True)
    report_file = "reports/cluster_vulnerabilities.json"
    
    with open(report_file, "w") as f:
        json.dump(report, f, indent=2)
    
    print("\n" + "=" * 70)
    print("SCAN SUMMARY")
    print("=" * 70)
    print(f"Total Findings: {report['total_findings']}")
    print(f"  CRITICAL: {report['findings_by_severity']['CRITICAL']}")
    print(f"  HIGH: {report['findings_by_severity']['HIGH']}")
    print(f"  MEDIUM: {report['findings_by_severity']['MEDIUM']}")
    print(f"  LOW: {report['findings_by_severity']['LOW']}")
    print(f"\n[+] Report saved to: {report_file}")

if __name__ == "__main__":
    main()

